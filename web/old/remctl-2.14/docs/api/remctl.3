.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "REMCTL 3"
.TH REMCTL 3 "2009-05-22" "2.14" "remctl Library Reference"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
remctl, remctl_result_free \- Simple remctl call to a remote server
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
#include <remctl.h>
.PP
struct remctl_result *
 \fBremctl\fR(const char *\fIhost\fR, unsigned short \fIport\fR,
        const char *\fIprincipal\fR, const char **\fIcommand\fR);
.PP
void \fBremctl_result_free\fR(struct remctl_result *\fIresult\fR);
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIremctl()\fR provides a simplified client \s-1API\s0 for the remctl protocol.  Given
the host, port, service principal for authentication, and command to run,
it opens a connection to the remote system, sends the command via the
remctl protocol, reads the results, closes the connection, and returns the
result as a remctl_result struct.
.PP
\&\fIhost\fR is a hostname or \s-1IP\s0 address and must be non-NULL.  \fIport\fR is the
port to connect to; if 0, the library first attempts to connect to the
registered port of 4373 and then tries the legacy port of 4444 if that
fails.  Future versions of the library will drop this fallback to 4444.
\&\fIprincipal\fR is the service principal to use for authentication; if \s-1NULL\s0,
\&\f(CW\*(C`host/\f(CIhost\f(CW\*(C'\fR is used, with the realm determined by domain-realm
mapping.  \fIcommand\fR is the command to run as a NULL-terminated array of
NUL-terminated strings.
.PP
If no principal is specified and the default is used, the underlying
GSS-API library may canonicalize \fIhost\fR via \s-1DNS\s0 before determining the
service principal, depending on your library configuration.  Specifying a
principal disables this behavior.
.PP
The remctl protocol uses Kerberos v5 via GSS-API for authentication.  The
underlying GSS-API library will use the default ticket cache for
authentication, so to successfully use \fIremctl()\fR, the caller should already
have Kerberos tickets for an appropriate realm stored in its default
ticket cache.  The environment variable \s-1KRB5CCNAME\s0 can be used to control
which ticket cache is used.
.PP
\&\fIremctl()\fR returns a newly allocated remctl_result struct, which has the
following members:
.PP
.Vb 8
\&    struct remctl_result {
\&        char *error;                /* remctl error if non\-NULL. */
\&        char *stdout_buf;           /* Standard output. */
\&        size_t stdout_len;          /* Length of standard output. */
\&        char *stderr_buf;           /* Standard error. */
\&        size_t stderr_len;          /* Length of standard error. */
\&        int status;                 /* Exit status of remote command. */
\&    };
.Ve
.PP
If error is non-NULL, a protocol error occurred and the command was not
successfully completed.  Otherwise, standard output from the command will
be stored in stdout_buf with the length in stdout_len, standard error from
the command will be stored in stderr_buf with the length in stderr_len,
and status will hold the exit status of the command.  Following the
standard Unix convention, a 0 status should normally be considered success
and any non-zero status should normally be considered failure, although a
given command may have its own exit status conventions.
.PP
\&\fIremctl_result_free()\fR frees the remctl_result struct when the calling
program is through with it.
.PP
If you want more control over the steps of the protocol, if you want to
issue multiple commands on the same connection, or if you need to send
data as part of the command that contains NULs, use the full \s-1API\s0 described
in \fIremctl_new\fR\|(3), \fIremctl_open\fR\|(3), \fIremctl_commandv\fR\|(3), and
\&\fIremctl_output\fR\|(3).
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
\&\fIremctl()\fR returns \s-1NULL\s0 on failure to allocate a new remctl_result struct or
on failure to allocate space to store an error message.  Otherwise, it
returns a newly allocated remctl_result struct with either an error
message in the error field or the results of the command filled out as
described above.  If \fIremctl()\fR returns \s-1NULL\s0, errno will be set to an
appropriate error code (generally \s-1ENOMEM\s0).
.SH "CAVEATS"
.IX Header "CAVEATS"
If the \fIprincipal\fR argument to \fIremctl()\fR is \s-1NULL\s0, most GSS-API libraries
will canonicalize the \fIhost\fR using \s-1DNS\s0 before deriving the principal name
from it.  This means that when connecting to a remctl server via a \s-1CNAME\s0,
\&\fIremctl()\fR will normally authenticate using a principal based on the
canonical name of the host instead of the specified \fIhost\fR parameter.
This behavior may cause problems if two consecutive \s-1DNS\s0 lookups of \fIhost\fR
may return two different results, such as with some DNS-based
load-balancing systems.
.PP
The canonicalization behavior is controlled by the GSS-API library; with
the \s-1MIT\s0 Kerberos GSS-API library, canonicalization can be disabled by
setting \f(CW\*(C`rdns\*(C'\fR to false in the [libdefaults] section of \fIkrb5.conf\fR.  It
can also be disabled by passing an explicit Kerberos principal name via
the \fIprincipal\fR argument, which will then be used without changes.  If
canonicalization is desired, the caller may wish to canonicalize \fIhost\fR
before calling \fIremctl()\fR to avoid problems with multiple \s-1DNS\s0 calls
returning different results.
.PP
The default behavior, when a port of 0 is given, of trying 4373 and
falling back to 4444 will be removed in a future version of this library
in favor of using the \f(CW\*(C`remctl\*(C'\fR service in \fI/etc/services\fR if set and
then falling back on only 4373.  4444 was the poorly-chosen original
remctl port and should be phased out.
.SH "NOTES"
.IX Header "NOTES"
The remctl port number, 4373, was derived by tracing the diagonals of a
\&\s-1QWERTY\s0 keyboard up from the letters \f(CW\*(C`remc\*(C'\fR to the number row.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIremctl_new\fR\|(3), \fIremctl_open\fR\|(3), \fIremctl_command\fR\|(3), \fIremctl_commandv\fR\|(3),
\&\fIremctl_output\fR\|(3), \fIremctl_close\fR\|(3)
.PP
The current version of the remctl library and complete details of the
remctl protocol are available from its web page at
<http://www.eyrie.org/~eagle/software/remctl/>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>
